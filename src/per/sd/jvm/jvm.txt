	一、jvm内存区域
	
	1、程序计数器：此区域为线程私有，程序启动后会为每个线程分配一个程序计数器，可以看作是程序执行的字节码的行号计数器，
				字节码指令、分支、循环、跳转、异常处理、线程恢复等都需要靠这个计数器来完成。
				
	2、java虚拟机栈：此区域为线程私有，描述的是java方法执行的内存模型，在方法执行时，会建立一个栈帧，用来存放局部变量表、
				操作数栈、动态链接、方法出口等信息，每一个方法执行的过程就是一个栈帧从入栈到出栈的过程。
				局部变量表里存放了所有的基本类型和对象的引用等信息。
	
	3、本地方法栈：此区域为线程共享、存放本地方法。
	
	4、java堆：此区域为线程共享，用来存放java的对象信息，是jvm中数据区最大的一块内存，也是gc主要工作的区域。
	
	5、方法区：此区域为线程共享，用来存放已经被虚拟机加载的类信息、常量、静态变量等。gc在这里的工作效率较差
		运行时常量池：方法区的一部分，用来存放编译期产生的各种字面量和符号引用。具备动态性。（比如，在创建一个string字符串时
		会先在常量池中寻找是否存在相同内容的对象，若有，则将该对象的地址赋予新建的引用）
	
	
	二、java对象
	1、创建过程：java对象在创建时为了保证线程安全，有两种方案，一是进行线程同步
			二是把内存分配的动作按照线程划分在不同的空间之中进行，即为每个线程分配一小块内存区域(本地线程分配缓冲TLAB)
			然后哪个线程要分配内存，就在哪个线程的TLAB上分配，当TLAB内存用完时，才需要同步锁定。
			内存分配完成之后，虚拟机会为已分配的内存分空间初始化为零值，所以java对象实例可以直接访问其字段数据类型对应的零值。
	2、对象信息：对象头
				1）对象运行时的信息（哈希码、gc分代年龄、锁状态标志、线程持有的锁）
				2）类型指针
				如果对象是数组，还有一部分是存放数组的大小
	3、对象访问定位：1）句柄（java虚拟机栈本地变量表（引用）-----》句柄池（对象实例的指针）------》对象实例数据----》对象类型数据）
				 2）直接指针（java虚拟机栈本地变量表（引用）----》对象指针（数据）-----》对象类型数据）
	4、对象的生命期，并非被gc回收后直接清除，而是进行第二次确认，第一次标记后进行筛选，判断对象是否执行了finalize方法，有就
	可能存活下去（需要方法里与其它对象建立关联），没有就清除掉。finalize是个低等级的线程。
				 
	三、垃圾收集器（gc）
	1、引用计数算法
		此方法最为简单，给对象添加一个计数器，每当有一个地方引用它，计数器加一，能解决大部分问题，
		但是无法解决对象相互引用的问题
	2、可达性分析法
		从gc roots对象作为起点，往下搜索，没有搜索到的进行回收。
	3、标记-清除法
		以可达性分析法为基础，为每个不可达对象进行标记，然后统一清除（会产生很多空间碎片，造成浪费）
	4、复制算法
		将内存分为一个个内存块，每个内存块只用一半，然后将存活对象全复制到另一半上，最后对之前的一半进行回收（一半内存浪费）
		注：因为大多数对象生命周期极短（98%左右），在第一次垃圾回收时就能清除，故不需要一半一半分配，可以按照9:1进行分配，
		这样只会造成10%的浪费
		事实上分代算法就是这么做的将初生代分为三个部分eden：from：to = 8:1:1
	5、分代算法
		1）初生代
			eden区和两个survivor区（from、to），每次使用eden区和from区分配内存
			回收时将存活内存放进to区，为了保证内存够用，有时候会放进老年代
		2）老年代一般使用标记清理或者标记整理法
		3）永久代
	6、标记整理法
		将存活对象的区域往一个方向移动，然后直接清理掉端边界以外的内存
		
	